const{isArray:A}=Array;const{keys:_}=Object;export class RecordBase{id=''}export class DataRecord extends RecordBase{deletedTimestamp}export class RecordStore{#database;#storeName;#tables;#useSoftDelete=!1;#softDeleteTimestampPropertyName='deletedTimestamp';constructor(B,c,C,d){this.#database=B;this.#storeName=c;this.#tables=C;d!=null&&(this.#useSoftDelete=d.useSoftDelete||this.#useSoftDelete,this.#softDeleteTimestampPropertyName=d.softDeleteTimestampPropertyName||this.#softDeleteTimestampPropertyName)}openTransaction(_a='readwrite'){if(this.#database==null)throw Error('The database has not been opened.');return this.#database.transaction(this.#tables,_a)}async addRecord(D){await this.updateRecord(D);return!0}async addRecords(_A){return (await this.updateRecords(_A)).map(item=>item!=null)}getRecord(e){return new Promise((E,_b)=>{var _c=this.openTransaction('readonly'),_d=_c.objectStore(this.#storeName),_e=_d.get(e);_e.onsuccess=aA=>{E(aA.target.result)};_e.onerror=aB=>_b(aB)})}async getRecords(aC,_B){var _C=this.openTransaction('readonly'),_D=[];for(const aD of aC)_D.push(new Promise((aE,aF)=>{var aG=_C.objectStore(this.#storeName),aH=aG.get(aD);aH.onsuccess=aI=>{aE(aI.target.result)};aH.onerror=aJ=>aF(aJ)}));let _E=await Promise.all(_D);_B!=null&&(_E=_E.sort((a,b)=>a[_B]-b[_B]));return _E}async getAllRecords(aK){return new Promise((aL,aM)=>{var aN=this.openTransaction('readonly'),aO=aN.objectStore(this.#storeName),aP=aO.getAll();aP.onsuccess=aQ=>{let aR=aQ.target.result;aK!=null&&(aR=aR.sort((a,b)=>a[aK]-b[aK]));aL(aR)};aP.onerror=aS=>aM(aS)})}async query(aT,aU){return new Promise((aV,aW)=>{var aX=this.openTransaction('readonly'),aY=aX.objectStore(this.#storeName),aZ=_(aT),f=Object.values(aT),g=aZ.length>1,n=[];let h=null;if(g)try{var I=aZ.join('+');h=aY.index(I)}catch(_){}var J=h!=null;if(h==null){var k=aZ[0];h=(k=='id')?aY:aY.index(k)}let l;let m=!1;!J&&A((f==null)?null:(J)?f:f[0])?l=h.openCursor():m=!0;l.onsuccess=bA=>{var bB=bA.target.result;if(bB==null){let bD=n;aU!=null&&(bD=n.toSorted((a,b)=>a[aU]-b[aU]));aV(bD);return}let bC=!1;for(let i=(m==!0)?1:0;i<aZ.length;i++){const bE=bB.value[aZ[i]],bF=f[i];if(A(bF)){let bG=!1;for(const bH of bF)bE==bH&&(bG=!0);if(bG==!1){bC=!0;break}}else if(bB.value[aZ[i]]!=bF){bC=!0;break}}!bC&&n.push(bB.value);bB.continue()};l.onerror=bI=>aW(bI)})}updateRecord(bJ){return new Promise((bK,bL)=>{var bM=this.openTransaction(),bN=bM.objectStore(this.#storeName),bO=bN.put(bJ);bO.onsuccess=bP=>{var bQ=bN.get(bP.target.result);bQ.onerror=bR=>bL(bR);bQ.onsuccess=bS=>{bK(bS.target.result)}};bO.onerror=bT=>bL(bT)})}async updateRecords(bU){var bV=this.openTransaction(),bW=[];for(const bX of bU)bW.push(new Promise((bY,bZ)=>{var cA=bV.objectStore(this.#storeName),cB=cA.put(bX);cB.onsuccess=cC=>{bY(cC.target.result)};cB.onerror=cD=>bZ(cD)}));return await this.getRecords(await Promise.all(bW))}removeRecord(cE,cF=!1){if(!cF&&this.#useSoftDelete)return this.setIsDeletedSingle(cE,!0);return new Promise((cG,cH)=>{var cI=this.openTransaction(),cJ=cI.objectStore(this.#storeName),cK=cJ.delete(cE);cK.onsuccess=cL=>{cG(cL.target.result)};cK.onerror=cM=>cH(cM)})}removeRecords(cN,cO=!1){if(!cO&&this.#useSoftDelete)return this.setIsDeletedMultiple(cN,!0);return new Promise((cP,cQ)=>{var cR=this.openTransaction(),cS=cR.objectStore(this.#storeName),cT=[],F=cU=>{if(cU>cN.length-1){cP(cT);return}const cV=cS.delete(cN[cU]);cV.onsuccess=()=>{cT.push(!0);F(cU+1)}};F(0);cR.onabort=cW=>{console.log('Transaction Aborted');cQ(cW)};cR.oncomplete=cX=>{cP(cX.target.result)}})}restoreRecord=id=>this.setIsDeletedSingle(id,!1);restoreRecords=ids=>this.setIsDeletedMultiple(ids,!1);async setIsDeletedSingle(cY,cZ){var dA=await this.getRecord(cY);dA[this.#softDeleteTimestampPropertyName]=(cZ==!0)?Date.now():void 0;await this.updateRecord(dA);return!0}async setIsDeletedMultiple(dB,dC){var dD=await this.getRecords(dB);for(let i=0;i<dD.length;i++)dD[i][this.#softDeleteTimestampPropertyName]=(dC==!0)?Date.now():void 0;await this.updateRecords(dD);return Array().fill(!0,0,dD.length-1)}clear(){return new Promise((dE,dF)=>{var dG=this.openTransaction(),dH=dG.objectStore(this.#storeName),dI=dH.clear();dI.onsuccess=dJ=>{dE(dJ.target.result)};dI.onerror=dK=>dF(dK)})}}export class RecordSetter{#isOpen=!1;#isInitialized=!1;#database;#keyValueTableName='keyValue';stores=new Map();static async activate(dL){var dM=new RecordSetter();var dN=await dM.open(dL);if(dN==!1)throw Error('An error occurred opening the database.');return dM}async open(dO){await this.#openDatabase(dO);return this.#isOpen&&this.#isInitialized}async #openDatabase(dP){return new Promise((dQ,dR)=>{var dS=indexedDB.open(dP.name,dP.version);dS.onsuccess=dT=>{var dU=dT.target;this.#database=dU.result;this.#isOpen=this.#isInitialized=!0;dQ()};dS.onupgradeneeded=async dV=>{var dW=dV.target;this.#database=dW.result;await this.#createDatabase(dP);this.#isInitialized=this.#isOpen=!0;dQ()};dS.onerror=dX=>dR(dX)})}async #createDatabase(dY){if(this.#isInitialized==!0)return;var dZ=[];for(const[eB,eC] of Object.entries(dY.schema)){var eA=eC.split(',').map(item=>item.trim());dZ.push(this.#createStorePromise(eB,eA))}_(dY.schema).indexOf(dY.keyValueTableName)==-1&&dZ.push(new Promise((eD,eE)=>{this.#keyValueTableName=dY.keyValueTableName??this.#keyValueTableName;var eF=this.#database.createObjectStore(this.#keyValueTableName,{keyPath:'key'});eF.transaction.oncomplete=eG=>eD();eF.transaction.onerror=eH=>eE(eH)}));return Promise.all(dZ)}async #createStorePromise(eI,eJ){var eK=Array();for(const eN of eJ){let eO=eN;let eP=eN;let eQ=!1;if(eN.startsWith('!')){eO=eN.substring(1);eQ=!0}else if(eN.startsWith('[')&&eN.endsWith(']')){eO=eN.substring(1,eN.length-1);var eL=eO.split('+');eP=eL}eK.push({name:eO,keyPath:eP,unique:eQ})}var eM=[],_f=this.#database.createObjectStore(eI,{keyPath:eK[0].keyPath});for(let i=1;i<eK.length;i++)eM.push(new Promise((eR,eS)=>{var eT=eK[i];_f.createIndex(eT.name,eT.keyPath,{unique:eT.unique,multiEntry:(!A(eT.keyPath))});if(A(eT.keyPath))for(let j=0;j<eT.keyPath.length;j++){const eU=eT.keyPath[j].startsWith('!'),eV=eU?eT.keyPath[j].substring(1):eT.keyPath[j];_f.createIndex(eV,eV,{unique:eU,multiEntry:!0})}_f.transaction.oncomplete=eW=>eR();_f.transaction.onerror=eX=>eS(eX)}));await Promise.all(eM)}async close(){if(this.#database==null){this.#isOpen=!1;return!this.#isOpen}this.#database.close();this.#isOpen=!1;return!this.#isOpen}async delete(){this.#isOpen&&await this.close();return this.#deleteDatabase()}#deleteDatabase(){return new Promise(eY=>{if(this.#database==null||this.#isInitialized!=!0)throw Error('Unable to delete an uninitialized database.');var eZ=indexedDB.deleteDatabase(this.#database.name);eZ.onsuccess=()=>{this.#database=void 0;this.#isInitialized=!1;eY(!0)};eZ.onerror=fA=>{console.error(fA);eY(!1)}})}openTransaction(fB,fC='readwrite'){if(this.#database==null)throw Error('The database has not been opened.');return this.#database.transaction(fB,fC)}addStore(fD,fE,fF){if(this.stores.get(fD)!=null)throw Error('Cannot add store with same name as existing store.');this.stores.set(fD,new RecordStore(this.#database, fD, fE??[fD], fF));return this.stores.get(fD)}getStore(fG){var fH=this.stores.get(fG);if(fH==null)throw Error(`Store could not be found by name: ${fG}`);return fH}async getKeyValueStore(){let fI=this.stores.get(this.#keyValueTableName);fI==null&&(fI=await this.addStore(this.#keyValueTableName));if(fI==null)throw Error('Unable to create a key-value store.');return fI}async getValue(fJ){return this.getData(this.#keyValueTableName,fJ)}async getValues(fK){return this.getDataValues(this.#keyValueTableName,fK)}async getAllValues(){return this.getAllData(this.#keyValueTableName)}async setValue(fL,fM){await this.setData(this.#keyValueTableName,fL,fM)}async setValues(fN){await this.setDataValues(this.#keyValueTableName,fN)}async getAllData(fO){if(this.#database==null)throw Error('The database has not been opened.');var fP=this.openTransaction([fO],'readonly');fP.onerror=fR=>{throw fR};var fQ=await new Promise((fS,fT)=>{const fU=fP.objectStore(fO),fV=fU.getAll();fV.onsuccess=fW=>{const fX=fW.target.result;fS(fX==null?[]:fX.value)};fV.onerror=fY=>fT(fY)});return fQ}async getData(fZ,gA){if(this.#database==null)throw Error('The database has not been opened.');var gB=this.openTransaction([fZ],'readonly');gB.onerror=gD=>{throw gD};var gC=await new Promise((gE,gF)=>{const gG=gB.objectStore(fZ),gH=gG.get(gA);gH.onsuccess=gI=>{const gJ=gI.target.result;gE(gJ==null?null:gJ.value)};gH.onerror=gK=>gF(gK)});return gC}async getDataValues(gL,gM){var gN=this.openTransaction([gL],'readonly'),gO=[];for(const gP of gM)gO.push(new Promise((gQ,gR)=>{var gS=gN.objectStore(gL),gT=gS.get(gP);gT.onsuccess=gU=>{var gV=gU.target.result;gQ(gV==null?null:gV.value)};gT.onerror=gW=>gR(gW)}));return await Promise.all(gO)}async setData(gX,gY,hA){if(this.#database==null)throw Error('The database has not been opened.');var gZ=this.openTransaction([gX]);gZ.onerror=hB=>{throw hB};await new Promise((hC,hD)=>{var hE=gZ.objectStore(gX),hF=(hA==void 0)?hE.delete(gY):hE.put({key:gY,value:hA});hF.onsuccess=hG=>{hC(hG.target.result)};hF.onerror=hH=>hD(hH)})}async setDataValues(hI,hJ){if(this.#database==null)throw Error('The database has not been opened.');var hK=this.openTransaction([hI]),hM=[];hK.onerror=hN=>{throw hN};var hL=hK.objectStore(hI);for(const hO of hJ)hM.push(new Promise((hP,hQ)=>{var hR=(hO.value==void 0)?hL.delete(hO.key):hL.put(hO);hR.onsuccess=hS=>{hP(hS.target.result)};hR.onerror=hT=>hQ(hT)}));await Promise.all(hM)}async removeData(hU,...hV){if(this.#database==null)throw Error('The database has not been opened.');var hW=this.openTransaction([hU]);hW.onerror=hX=>{throw hX};await new Promise((hY,hZ)=>{var iA=hW.objectStore(hU),iB=[];for(const iC of hV)iB.push(new Promise((iD,iE)=>{var iF=iA.delete(iC);iF.onsuccess=iG=>{iD(iG.target.result)};iF.onerror=iH=>iE(iH)}));hY(Promise.all(iB))})}async getKeys(iI,...iJ){if(this.#database==null)throw Error('The database has not been opened.');var iK=this.openTransaction([iI],'readonly');iK.onerror=iM=>{throw iM};var iL=await new Promise((iN,iO)=>{const iP=iK.objectStore(iI),iQ=(iJ.length==0)?iP.getAll():iP.get(iJ);iQ.onsuccess=iR=>{const iS=iR.target.result;iN((iS==null)?[]:iS.map(item=>item.key))};iQ.onerror=iT=>iO(iT)});return iL}async setKey(iU,iV){if(this.#database==null)throw Error('The database has not been opened.');var iW=this.openTransaction([iU]);iW.onerror=iY=>{throw iY};var iX=await new Promise((iZ,jA)=>{const jB=iW.objectStore(iU),jC=jB.put({key:iV});jC.onsuccess=jD=>{iZ(jD.target.result)};jC.onerror=jE=>jA(jE)});return iX}async setKeys(jF,jG){if(this.#database==null)throw Error('The database has not been opened.');var jH=this.openTransaction([jF]),jI=[];for(const jK of jG)jI.push(new Promise((jL,jM)=>{var jN=jH.objectStore(jF),jO=jN.put({key:jK});jO.onsuccess=jP=>{jL(jP.target.result)};jO.onerror=jQ=>jM(jQ)}));var jJ=await Promise.all(jI);return await this.getKeys(jF,...jJ)}async removeKey(jR,jS){if(this.#database==null)throw Error('The database has not been opened.');var jT=this.openTransaction([jR]);jT.onerror=jU=>{throw jU};await new Promise((jV,jW)=>{var jX=jT.objectStore(jR),jY=jX.delete(jS);jY.onsuccess=jZ=>{jV(jZ.target.result)};jY.onerror=kA=>jW(kA)})}async clearStoreKeys(kB){if(this.#database==null)throw Error('The database has not been opened.');var kC=this.openTransaction([kB]);kC.onerror=kD=>{throw kD};await new Promise((kE,kF)=>{var kG=kC.objectStore(kB),kH=kG.clear();kH.onsuccess=kI=>{kE(kI.target.result)};kH.onerror=kJ=>kF(kJ)})}static generateId(){var kK=new Uint8Array(20);crypto.getRandomValues(kK);var kL=btoa([].slice.apply(kK).map(kM=>String.fromCharCode(kM)).join('')).replace(/\//g,'_').replace(/\+/g,'-').replace(/=/g,'');return kL}}
