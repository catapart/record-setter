export class DataRecord{id=""}export class RecordStore{#a;#b;#c;#d=!1;#e="deletedTimestamp";constructor(e,t,a,s){this.#a=e,this.#b=t,this.#c=a,null!=s&&(this.#d=s.useSoftDelete||this.#d,this.#e=s.softDeleteTimestampPropertyName||this.#e)}openTransaction(e="readwrite"){if(null==this.#a)throw Error("The database has not been opened.");return this.#a.transaction(this.#c,e)}async addRecord(e){return await this.updateRecord(e),!0}async addRecords(e){return(await this.updateRecords(e)).map(e=>null!=e)}getRecord(e){return new Promise((t,a)=>{let s=this.openTransaction("readonly"),r=s.objectStore(this.#b),n=r.get(e);n.onsuccess=e=>{let a=e.target.result;t(a)},n.onerror=e=>{a(e)}})}async getRecords(e,t){let a=this.openTransaction("readonly"),s=[];for(let r=0;r<e.length;r++){let n=e[r];s.push(new Promise((e,t)=>{let s=a.objectStore(this.#b),r=s.get(n);r.onsuccess=t=>{let a=t.target.result;e(a)},r.onerror=e=>{t(e)}}))}let l=await Promise.all(s);return null!=t&&(l=l.sort((e,a)=>e[t]-a[t])),l}async getAllRecords(e){return new Promise((t,a)=>{let s=this.openTransaction("readonly"),r=s.objectStore(this.#b),n=r.getAll();n.onsuccess=a=>{let s=a.target.result;null!=e&&(s=s.sort((t,a)=>t[e]-a[e])),t(s)},n.onerror=e=>{a(e)}})}async query(e,t){return new Promise((a,s)=>{let r=this.openTransaction("readonly"),n=r.objectStore(this.#b),l=Object.keys(e),o=Object.values(e),i=l.length>1,h=null;if(i)try{let u=l.join("+");h=n.index(u)}catch(c){}let d=null!=h;if(null==h){let b=l[0];h="id"==b?n:n.index(b)}let p=null==o?null:d?o:o[0],y,g=!1;!d&&Array.isArray(p)?y=h.openCursor():(g=!0,y=h.openCursor(IDBKeyRange.only(p)));let w=[];y.onsuccess=e=>{let s=e.target.result;if(null==s){let r=w;null!=t&&(r=w.toSorted((e,a)=>e[t]-a[t])),a(r);return}let n=!1;for(let i=!0==g?1:0;i<l.length;i++){let h=s.value[l[i]],u=o[i];if(Array.isArray(u)){let c=!1;for(let d=0;d<u.length;d++){let b=u[d];h==b&&(c=!0)}if(!1==c){n=!0;break}}else if(s.value[l[i]]!=u){n=!0;break}}n||w.push(s.value),s.continue()},y.onerror=e=>{s(e)}})}updateRecord(e){return new Promise((t,a)=>{let s=this.openTransaction(),r=s.objectStore(this.#b),n=r.put(e);n.onsuccess=async e=>{let s=e.target.result,n=r.get(s);n.onerror=e=>{a(e)},n.onsuccess=e=>{let a=e.target.result;t(a)}},n.onerror=e=>{a(e)}})}async updateRecords(e){let t=this.openTransaction(),a=[];for(let s=0;s<e.length;s++){let r=e[s];a.push(new Promise((e,a)=>{let s=t.objectStore(this.#b),n=s.put(r);n.onsuccess=t=>{let a=t.target.result;e(a)},n.onerror=e=>{a(e)}}))}let n=await Promise.all(a),l=await this.getRecords(n);return l}removeRecord(e,t=!1){return!t&&this.#d?this.setIsDeletedSingle(e,!0):new Promise((t,a)=>{let s=this.openTransaction(),r=s.objectStore(this.#b),n=r.delete(e);n.onsuccess=e=>{let a=e.target.result;t(a)},n.onerror=e=>{a(e)}})}removeRecords(e,t=!1){return!t&&this.#d?this.setIsDeletedMultiple(e,!0):new Promise((t,a)=>{let s=this.openTransaction(),r=s.objectStore(this.#b),n=[],l=a=>{if(a>e.length-1){t(n);return}let s=r.delete(e[a]);s.onsuccess=()=>{n.push(!0),l(a+1)}};l(0),s.onabort=function(e){console.log("Transaction Aborted"),a(e)},s.oncomplete=function(e){let a=e.target.result;t(a)}})}restoreRecord=e=>this.setIsDeletedSingle(e,!1);restoreRecords=e=>this.setIsDeletedMultiple(e,!1);async setIsDeletedSingle(e,t){let a=await this.getRecord(e);return a[this.#e]=!0==t?Date.now():void 0,await this.updateRecord(a),!0}async setIsDeletedMultiple(e,t){let a=await this.getRecords(e);for(let s=0;s<a.length;s++)a[s][this.#e]=!0==t?Date.now():void 0;return await this.updateRecords(a),[].fill(!0,0,a.length-1)}clear(){return new Promise((e,t)=>{let a=this.openTransaction(),s=a.objectStore(this.#b),r=s.clear();r.onsuccess=t=>{let a=t.target.result;e(a)},r.onerror=e=>{t(e)}})}}export class RecordSetter{#f=!1;#g=!1;#a;#h="keyValue";stores=new Map;async open(e){return await this.openDatabase(e),this.#f&&this.#g}async openDatabase(e){return new Promise((t,a)=>{let s=indexedDB.open(e.name,e.version);s.onsuccess=e=>{let a=e.target;this.#a=a.result,this.#f=!0,this.#g=!0,t()},s.onupgradeneeded=async a=>{let s=a.target;this.#a=s.result,await this.createDatabase(e),this.#g=!0,this.#f=!0,t()},s.onerror=e=>{a(e)}})}async createDatabase(e){if(!0==this.#g)return;let t=[];for(let[a,s]of Object.entries(e.schema)){let r=s.split(",").map(e=>e.trim());t.push(this.createStorePromise(a,r))}return -1==Object.keys(e.schema).indexOf(e.keyValueTableName)&&t.push(new Promise((t,a)=>{this.#h=e.keyValueTableName??this.#h;let s=this.#a.createObjectStore(this.#h,{keyPath:"key"});s.transaction.oncomplete=e=>{t()},s.transaction.onerror=e=>{a(e)}})),Promise.all(t)}async createStorePromise(e,t){let a=[];for(let s=0;s<t.length;s++){let r=t[s],n=r,l=r,o=!1;if(r.startsWith("!"))n=r.substring(1),o=!0;else if(r.startsWith("[")&&r.endsWith("]")){n=r.substring(1,r.length-1);let i=n.split("+");l=i}a.push({name:n,keyPath:l,unique:o})}let h=[],u=this.#a.createObjectStore(e,{keyPath:a[0].keyPath});for(let c=1;c<a.length;c++)h.push(new Promise((e,t)=>{let s=a[c];if(u.createIndex(s.name,s.keyPath,{unique:s.unique,multiEntry:!Array.isArray(s.keyPath)}),Array.isArray(s.keyPath))for(let r=0;r<s.keyPath.length;r++){let n=!!s.keyPath[r].startsWith("!"),l=n?s.keyPath[r].substring(1):s.keyPath[r];u.createIndex(l,l,{unique:n,multiEntry:!0})}u.transaction.oncomplete=t=>{e()},u.transaction.onerror=e=>{t(e)}}));await Promise.all(h)}async close(){return null==this.#a?(this.#f=!1,!this.#f):(this.#a.close(),this.#f=!1,!this.#f)}async delete(){return this.#f&&await this.close(),this.deleteDatabase()}deleteDatabase(){return new Promise(e=>{if(null==this.#a||!0!=this.#g)throw Error("Unable to delete an uninitialized database.");let t=indexedDB.deleteDatabase(this.#a.name);t.onsuccess=()=>{this.#a=void 0,this.#g=!1,e(!0)},t.onerror=t=>{console.error(t),e(!1)}})}addStore(e,t,a){if(null!=this.stores.get(e))throw Error("Cannot add store with same name as existing store.");return this.stores.set(e,new RecordStore(this.#a,e,t??[e],a)),this.stores.get(e)}getStore(e){let t=this.stores.get(e);if(null==t)throw Error(`Store could not be found by name: ${e}`);return t}async getKeyValueStore(){let e=this.stores.get(this.#h);if(null==e&&(e=await this.addStore(this.#h)),null==e)throw Error("Unable to create a key-value store.");return e}async getValue(e){return this.getData(this.#h,e)}async getValues(e){return this.getDataValues(this.#h,e)}async getAllValues(){return this.getAllData(this.#h)}async setValue(e,t){return this.setData(this.#h,e,t)}async setValues(e){return this.setDataValues(this.#h,e)}async getAllData(e){if(null==this.#a)throw Error("The database has not been opened.");let t=this.openTransaction([e],"readonly");t.onerror=e=>{throw e};let a=await new Promise((a,s)=>{let r=t.objectStore(e),n=r.getAll();n.onsuccess=e=>{let t=e.target.result,s=null==t?[]:t.value;a(s)},n.onerror=e=>{s(e)}});return a}async getData(e,t){if(null==this.#a)throw Error("The database has not been opened.");let a=this.openTransaction([e],"readonly");a.onerror=e=>{throw e};let s=await new Promise((s,r)=>{let n=a.objectStore(e),l=n.get(t);l.onsuccess=e=>{let t=e.target.result,a=null==t?null:t.value;s(a)},l.onerror=e=>{r(e)}});return s}async getDataValues(e,t){let a=this.openTransaction([e],"readonly"),s=[];for(let r=0;r<t.length;r++){let n=t[r];s.push(new Promise((t,s)=>{let r=a.objectStore(e),l=r.get(n);l.onsuccess=e=>{let a=e.target.result;t(null==a?null:a.value)},l.onerror=e=>{s(e)}}))}let l=await Promise.all(s);return l}async setData(e,t,a){if(null==this.#a)throw Error("The database has not been opened.");let s=this.openTransaction([e]);s.onerror=e=>{throw e};let r=await new Promise((r,n)=>{let l=s.objectStore(e),o=void 0==a?l.delete(t):l.put({key:t,value:a});o.onsuccess=e=>{let t=e.target.result;r(t)},o.onerror=e=>{n(e)}});return r}async setDataValues(e,t){if(null==this.#a)throw Error("The database has not been opened.");let a=this.openTransaction([e]);a.onerror=e=>{throw e};let s=a.objectStore(e),r=[];for(let n=0;n<t.length;n++){let l=t[n];r.push(new Promise((e,t)=>{let a=void 0==l.value?s.delete(l.key):s.put(l);a.onsuccess=t=>{let a=t.target.result;e(a)},a.onerror=e=>{t(e)}}))}await Promise.all(r)}async removeData(e,...t){if(null==this.#a)throw Error("The database has not been opened.");let a=this.openTransaction([e]);return a.onerror=e=>{throw e},await new Promise((s,r)=>{let n=a.objectStore(e),l=[];for(let o=0;o<t.length;o++){let i=t[o];l.push(new Promise((e,t)=>{let a=n.delete(i);a.onsuccess=t=>{let a=t.target.result;e(a)},a.onerror=e=>{t(e)}}))}s(Promise.all(l))})}async getKeys(e,...t){if(null==this.#a)throw Error("The database has not been opened.");let a=this.openTransaction([e],"readonly");a.onerror=e=>{throw e};let s=await new Promise((s,r)=>{let n=a.objectStore(e),l=0==t.length?n.getAll():n.get(t);l.onsuccess=e=>{let t=e.target.result;s(null==t?[]:t.map(e=>e.key))},l.onerror=e=>{r(e)}});return s}async setKey(e,t){if(null==this.#a)throw Error("The database has not been opened.");let a=this.openTransaction([e]);a.onerror=e=>{throw e};let s=await new Promise((s,r)=>{let n=a.objectStore(e),l=n.put({key:t});l.onsuccess=e=>{let t=e.target.result;s(t)},l.onerror=e=>{r(e)}});return s}async setKeys(e,t){if(null==this.#a)throw Error("The database has not been opened.");let a=this.openTransaction([e]),s=[];for(let r=0;r<t.length;r++){let n=t[r];s.push(new Promise((t,s)=>{let r=a.objectStore(e),l=r.put({key:n});l.onsuccess=e=>{let a=e.target.result;t(a)},l.onerror=e=>{s(e)}}))}let l=await Promise.all(s),o=await this.getKeys(e,...l);return o}async removeKey(e,t){if(null==this.#a)throw Error("The database has not been opened.");let a=this.openTransaction([e]);return a.onerror=e=>{throw e},new Promise((s,r)=>{let n=a.objectStore(e),l=n.delete(t);l.onsuccess=e=>{let t=e.target.result;s(t)},l.onerror=e=>{r(e)}})}async clearStoreKeys(e){if(null==this.#a)throw Error("The database has not been opened.");let t=this.openTransaction([e]);return t.onerror=e=>{throw e},new Promise((a,s)=>{let r=t.objectStore(e),n=r.clear();n.onsuccess=e=>{let t=e.target.result;a(t)},n.onerror=e=>{s(e)}})}openTransaction(e,t="readwrite"){if(null==this.#a)throw Error("The database has not been opened.");return this.#a.transaction(e,t)}static generateId(){let e=new Uint8Array(20);crypto.getRandomValues(e);let t=[].slice.apply(e).map(function(e){return String.fromCharCode(e)}).join(""),a=btoa(t).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,"");return a}}